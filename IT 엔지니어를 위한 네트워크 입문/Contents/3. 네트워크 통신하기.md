# 3. 네트워크 통신하기

이번 장에서는 네트워크 통신 과정에서 필요한 주소인 MAC 주소, IP 주소에 대해 다루려고 합니다.  
주소 체계를 이루는 서브넷, 게이트웨이와 같은 용어와 ARP와 같은 프로토콜의 기능과 역할에 대해 상세히 알아보겠습니다.

## 1. 유니캐스트, 멀티캐스트, 브로드캐스트, 애니캐스트

네트워크에서 출발지에서 목적지로 데이터를 전송할 때 사용하는 통신 방식에는 유니, 브로드, 멀티, 애니 캐스트가 있습니다.
각 통신 방식은 다음과 같습니다.

- 유니캐스트 : 1 vs 1 통신(출발지와 목적지가 1 : 1 통신)
- 브로드 캐스트 : 1 vs 모든 통신(동일 네트워크에 존재하는 모든 호스트가 목적지)
- 멀티 캐스트 : 1 vs 그룹 통신(멀티캐스트 구독 호스트)통신(하나의 출발지에서 다수의 특정 목적지로 데이터 전송)
- 애니캐스트 : 1 vs 1 통신(목적지는 동일 그룹 내의 1개 호스트)(다수의 동일 그룹 중 가장 가까운 호스트에서 응답, IPv4에서는 일부 기능 구현, IPv6는 모두 구현 가능)

그럼 각 통신 방식에 대해서 자세히 정리해보도록 하겠습니다.

### 유니 캐스트

---

유니 캐스트는 출발지와 목적지가 명확히 하나로 정해져 있는 1 : 1 통신 방식입니다.  
실제로 사용하는 대부분의 통신은 유니 캐스트 방식을 사용합니다.

![](https://camo.githubusercontent.com/beea6665f7d792b52b0fffcf1ada691ee008834b3c6341977804eb967b2f369b/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f64353066393831372d626439332d343963392d393664642d6333313462306332313532342f696d6167652e706e67)

### 브로드 캐스트

---

브로드 캐스트는 목적지 주소가 모든으로 표시되어 있는 통신 방식입니다. 유니캐스트로 통신하기전, 주로 상대방의 정확한 위치를 알기 위해 사용됩니다.  
주소 체계에 따라 브로드캐스트를 다양하게 분류할 수 있지만 기본 동작은 로컬 네트워크 내에서 모든 호스트에 패킷을 전달해야 할 때 사용됩니다.

![](https://camo.githubusercontent.com/5f0060097b38fc84ef34b7e850cd6c97cb47f8fcc15808b937f941bdfa7489f3/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f38663165633236632d323162352d343261342d383937642d3432323436306164376533652f696d6167652e706e67)

### 멀티 캐스트

멀티 캐스트는 멀티 캐스트 그룹 주소를 이용해 해당 그룹에 속한 다수의 호스트로 패킷을 전송하기 위한 통신 방식입니다.  
IPTV와 같은 실시간 방송을 볼 때 이 멀티캐스트 통신 방식을 사용합니다. 사내 방송이나 중권 시세 전송과 같이 단방향으로  
다수에게 동시에 같은 내용을 전달해야 할 떄 사용합니다.

![](https://camo.githubusercontent.com/b130cbc6ac8487b2accff185081c3e5548b18c5d2a8a160945b4e5bd532b46ab/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f38633131663930352d303033632d346138302d396330632d6337663832333962643332392f696d6167652e706e67)

### 애니 캐스트

애니 캐스트는 주소가 같은 호스트들 중에서 가깝거나 가장 효율적으로 서비스할 수 있는 호스트와 통신하는 방식입니다.  
이런 애니 캐스트 게이트웨이의 성질을 이용해서 가장 가까운 DNS 서버를 찾을 때 사용하거나 가장 가까운 게이트웨이를  
찾는 애니캐스트 게이트웨이 기능에 사용하기도 합니다.

![](https://camo.githubusercontent.com/ad3769786099b2d7dc7efa9ec2eb111f45abf6488774b279e08e16069f275464/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f64363836626330322d353637342d346134392d393664342d3763666331323834393139372f696d6167652e706e67)

**❗️ 주의**
최종 통신은 1 : 1 로 유니 캐스트와 동일하자만 통신할 수 있는 후보자는 서로 다릅니다. 유니 캐스트는 출발지와 목적지가  
모두 한 대씩이지만 애니캐스트는 같은 목적지 주소를 가진 서버가 여러 대여서 통신 가능한 다수의 후보군이 있습니다.

### 정리

- 현재 주로 사용되는 네트워크 체계는 IPv4 기반입니다.
- 일부 모바일 네트워크와 대규모 데이터 센터 위주로는 새로운 IPv6 기반 주소 체계가 사용되고 있습니다.
- IPv6 에서는 브로드 캐스트가 존재하지 않고 링크 로컬 멀티캐스트로 대체되어 사용됩니다.

4가지 통신 방식을 간단하게 표로 정리하면 다음과 같습니다.  
| 타입 | 통신 대상 | 범위 | IPv4 | IPv6 | 예제 |
| ------------ | ---------- | --------------------- | ---- | ---- | ---------- |
| 유니캐스트 | 1:1 | 전체 네트워크 | o | o | HTTP |
| 브로드캐스트 | 1:N(ALL) | 서브넷(로컬 네트워크) | o | x | ARP |
| 멀티캐스트 | 1:N(Group) | 정의된 구간 | o | o | 방송 |
| 애니캐스트 | 1:1 | 전체 네트워크 | △ | o | 6 to 4 DNS |

## 2. MAC 주소

MAC 주소는 Media Access Control의 줄임말로 **2계층(데이터 링크 계층)** 에서 통신을 위해 **네트워크 인터페이스에 할당된 고유 식별자** 입니다.  
MAC 주소는 이더넷과 와이파이를 포함한 대부분의 IEEE 802 네트워크 기술에서 2계층 주소로 사용됩니다. 네트워크에 접속하는 모든 장비는 MAC 주소라는  
물리적인 주소가 있어야 하고 이 주소를 이용해 서로 통신하게 됩니다.

### MAC 주소 체계

MAC 주소는 **변경할 수 없도록 하드웨어에 고정되어 출하** 되므로 네트워크 구성 요소마다 다른 주소를 가지고 있습니다.  
모든 네트워크 장비 제조업체에서 장비가 출하될 때마다 MAC 주소를 할당하게 되는데 매번 **이 주소의 할당 여부를 확인할 수 없으므로**  
**한 제조업체에 하나 이상의 주소풀을 주고 그 풀 안에서 할당하는 것을 제조사 코드(Vendor Code)**라고 부르며 이 주소는 국제 기구인 IEEE가 관리합니다.

MAC 주소는 48비트의 16진수 12자리로 표현됩니다. 48비트의 MAC 주소는 다시 다음과 같이 앞의 24비트와 뒤의 24비트로 나누어 구분하는데 앞에서 언급한 `제조사 코드`가  
MAC 주소 앞의 24비트인 OUT 값입니다. 뒤의 24비트 값인 UAA는 각 제조사에서 자체적으로 할당하여 네트워크에서 각 장비를 구분할 수 있게 해줍니다.

![](https://camo.githubusercontent.com/2bcc7a8c0c0cf3e655cc5cac7859242353ff17e8d0b627c84f04b35202b2f94c/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f66323030303538662d336439642d346663622d613434332d3933376465663162643965612f696d6167652e706e67)

- OUI : IEEE가 제조사에 할당하는 부분
- UAA : 각 제조사에서 네트워크 구성 요소에 할당하는 부분

이렇게 MAC 주소는 각 네트워크 장비 제조업체 코드와 제조업체가 자체적으로 할당하는 값으로 구성됩니다.  
네트워크 카드나 장비를 생산할 때 하드웨어적으로 정해져 나오므로 MAC 주소를 BIA(Burned-In Address)라고도 부릅니다.

> 👉 참고  
> **유일하지 않은 MAC 주소**  
> 흔히 MAC 주소는 유일한 값이라고 생각하지만 유일하지 않을 수도 있습니다. 네트워크 장비 제조업체는 자신의 제조업체 코드 내에서  
> 뒤의 24비트의 UAA 값을 할당하는데 실수나 의도적으로 MAC 주소가 중복될 수 있습니다.
>
> MAC 주소는 동일 네트워크에서만 중복되지 않으면 동작하는 데 문제가 없습니다. 네트워크 통신을 할 때 네트워크가 달라 라우터의 도움을 받아야 할 경우,  
> 라우터에서 다른 네트워크로 넘겨줄 때 출발지와 도착지의 MAC 주소가 변경되므로 네트워크를 넘어가면 기존 출발지와 도착지 MAC 주소를 유지하지 않습니다.

### MAC 주소 동작

NIC는 MAC 주소를 가지고 있고, 전기 신호가 들어오면 2계층에서 데이터 형태(패킷)로 변환하여 내용을 구분한 후 도착지 MAC 주소를 확인합니다.  
만약 도착지 MAC 주소가 자신이 가지고 있는 MAC 주소와 다르면 그 패킷을 폐기합니다. 패킷의 목적지 주소가 자기 자신이거나 브로드 캐스트, 멀티 캐스트와  
같은 그룹 주소이면 처리해야 할 주소로 인지해 패킷 정보를 상위 계층으로 넘겨줍니다.

![](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe104b339-64ae-4cd2-b688-ec27e952476e%2FUntitled.png&blockId=c1e93f16-c68a-48ef-a7b2-579ab1c480cc)

도착지 주소가 일치하지 않아 NIC에서 자체적으로 패킷을 패기하는 경우와 달리 본인 주소, 브로드 캐스트 주소는 NIC 자체적으로 패킷을 처리하는 것이 아니라  
OS나 애플리케이션에서 처리해야 하므로 시스템 부하가 작용됩니다.

> 👉 참고  
> **MAC 주소를 여러 개 갖는 경우**  
> MAC 주소는 단말에 종속되지 않고 NIC에 종속됩니다. 단말은 NIC를 여러 개 가질 수 있으므로 MAC 주소도 여러 개 가질 수 있습니다.  
> 멀티레이어 스위치, 라우터와 같은 복잡한 네트워크 장비는 NIC가 여러 개이고 MAC 주소도 여러 개가 할당됩니다.

## 3. IP 주소

OSI 7계층에서 주소를 갖는 계층은 2계층과 3계층입니다. 2계층은 물리 주소인 MAC 주소를 사용하고 3계층은 논리 주소인 IP 주소를 사용합니다.  
대부분의 네트워크가 TCP/IP로 동작하므로 IP 주소 체계를 이해하는 것이 네트워크 이해에 매우 중요합니다.

IP 주소를 포함한 다른 프로토콜 스택의 3계층 주소는 다음과 같은 특징이 있습니다.

- 사용자가 **변경 가능한 논리 주소** 입니다.
- 주소에 레벨이 있습니다. **그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉩니다.**

### IP 주소 체계

우리가 흔히 사용하는 IP 주소는 32비트인 IPv4 주소입니다. IP는 v4, v6 두 체계가 사용되며 IPv6 주소는 128비트입니다.  
IPv4 주소를 표기할 때는 4개의 옥텟(Octet)이라고 부르는 8비트 단위로 나누고 각 옥텟은 "."으로 구분합니다. 2계층의 MAC 주소가  
16진수로 표기된 것과 달리 IP 주소는 10진수로 표기하므로 8비트 옥텟은 0~255의 값을 쓸 수 있습니다.

![](https://camo.githubusercontent.com/1e920ec8d82fee32c895dae8379b8d86cd194ca9343e2e2f49bc5ef1dd672dc2/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f61633733666530342d323736312d343764612d393836642d6639303839316139666532312f696d6167652e706e67)

2계층 주소인 MAC 주소가 제조업체 코드인 OUI와 제조업체별 일련 번호인 UAA의 두 부분으로 나뉘는 것과 목직이 다르지만 3계층 주소인  
IP 주소도 **네트워크 주소** 와 **호스트 주소** 두 부분으로 나뉩니다.

- 네트워크 주소 : 호스트들을 모은 네트워크를 지칭하는 주소, 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 함
- 호스트 주소 : 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소

MAC 주소는 24비트씩 절반으로 나뉘지만 IP 주소의 네트워크 주소와 호스트 주소는 이 둘을 구분하는 경계점이 고정되어 있지 않습니다.  
이것이 다른 주소 체계와 IP 주소 체계를 구분하는 가장 큰 특징입니다. IP 주소 체계는 필요한 호스트 IP 개수에 따라 네트워크 크기를  
다르게 할당할 수 있는 클래스 개념을 도입했습니다.

A 클래스는 가장 큰 주소를 갖는데 약 1,600만 개의 IP 주소를 가질 수 있습니다. B 클래스는 약 6만 5천개, C클래스는 약 250개의 IP 주소를 가질 수 있습니다.  
A 클래스는 첫 번째 옥텟에 네트워크 주소와 호스트 주소를 나누는 구분자가 있고 B 클래스는 두 번째 옥텟, C 클래스는 세번째 옥텟의 구분자가 있습니다. 이 구분자를 **서브넷 마스크** 라고 합니다.

### 서브네팅

원래 부여된 클래스의 기준을 무시하고 새로운 네트워크-호스트 구분 기준을사용자가 정해 원래 **클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브네팅** 이라고 합니다.  
부여된 주소를 다시 잘라 사용해 서브네팅이라고 부르는데 형재 클래스리스 네트워크의 가장 큰 특징입니다. 옥텟 단위로 구분되는 서브네팅은 이해와 운영이 쉽지만 실제로는  
옥텟 단위보다 더 잘게 쪼개 2진수의 1비트 단위로 네트워크를 분할하므로 서브네팅을 이해하기 어렵습니다.

![](https://camo.githubusercontent.com/1e79d8f46de6a3287f0f24705f82cdc7bf02933eaa36eebaccec38ae872b027f/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f38326530663536302d343030382d346461372d383037652d6238623339653763663031612f696d6167652e706e67)

실무에서 서브네팅에 대해 고민해야 하는 경우는 두 가지 입니다. 네트워크 디자인 단계에서 네트워크 설계자가 네트워크를 효율적으로 어떻게 분할 할 것인지 계획하는 경우와  
이미 분환된 네트워크에서 사용자가 자신의 네트워크와 원격지 네트워크를 구분해야 하는 경우입니다. 상황에 따라 고려해야 할 범위가 달라집니다.

- 네트워크 사용자 입장 : 네트워크에서 사용할 수 있는 IP 범위 파악, 기본 게이트웨이와 서브넷 마스크 설정이 제대로 되어 있는지 확인
- 네트워크 설계자 입장 : 네트워크 설계 시 네트워크 내에 필요한 단말ㅇ르 고려한 네트워크 범위 설계

### 공인 IP와 사설 IP

인터넷에 접속하려면 IP 주소가 있어야 하고 이 IP는 전 세계에서 유일해야 하는 식별자입니다. 이런 IP 주소를 공인 IP라고 합니다.  
하지만 인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 공인 IP 주소를 할당받지 않고도 네트워크를 구축할 수 있습니다.

이때 사용하는 IP 주소를 사설 IP 주소라고 합니다. 인터넷에 접속하려면 통신사업자로부터 IP 주소를 할당받거나 IP 할당기관(한국의 경우 KISA)에서  
인터넷 독립기관 주소를 할당 받은 후 독립 IP를 할당받아야 하므로 절차가 복잡합니다. 인터넷에 접속하지 않거나 NAT 기술을 사용할 경우에는 사설 IP 주소를 사용할 수 있습니다.

이 주소들은 인터넷 표준 문서인 RFC 에 명시되어 있습니다. 사설 IP를 사용하면 인터넷에 직접 접속하지 못하지만 IP를 변환해주는 NAT 장비에서 공인 IP로 변경한 후에 접속이 가능합니다.  
가정에서 많이 사용하는 공유기는 NAT 장비의 역할을 하는 대표적인 예입니다.

> 👉 참고  
> **인터넷 표준**  
> 인터넷 표준은 특별한 RFC(Request for Comments)와 그 집합을 가리킵니다. RFC의 원래 의미는 비평을 기다리는 문서로,  
> RFC 자체가 인터넷 표준 문서는 아니며 컴퓨터, 인터넷 기술에 적용할 수 있는 제안, 조사 결과, 아이디어 표준 등을 적어놓은 메모 형식의 문서 모음입니다.

## 4. TCP와 UDP

앞에서 설명한 2계층과 3계층의 목적지를 정확히 찾아가기 위한 주소 제공이 목적이었지만 4계층에서 동작하는 프로토콜은 만들어진 목적이 2,3 계층 프로토콜과 조금 다릅니다.  
목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할을 합니다.

이번 장에서는 TCP/IP 프로토콜 스택의 4계층에서 동작하는 TCP와 UDP 프로토콜에 대해서 상세히 다루어 보도록 하겠습니다.

### 4계층 프로토콜(TCP, UDP)과 서비스 포트

데이터를 보고 받은 인캡슐레이션, 디캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 여러가지 정보가 들어가게 됩니다. 다양한 정보 중 가장 중요한 정보는 다음과 같습니다.

- 각 계층에서 정의하는 정보
  - 각 계층을 정의하는 정보는 **수신 측의 동일 계층에서 사용하기 위한 정보입니다.** 예를 들어 송신 측에서 추가한 2계층 헤더의 MAC 주소 정보는 수신 측의 2계층에서 확인되고 사용됩니다.
  - 마찬가지로 송신 측에서 추가한 3게층 IP 주소는 수신 측 IP 3계층에서 사용됩니다. 4계층에서는 이런 정보로 시퀀스 번호, ACk 번호가 있습니다.
- 상위 프로토콜 지시자 정보
  - 상위 프로토콜 지시자는 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용됩니다.
  - 2계층은 이더 타입, 3계층은 프로토콜 번호, 4계층은 포트 번호가 상위 프로토콜 지시자 입니다.

TCP/IP 플로토콜 스택에서 4계층은 TCP와 UDP가 담당합니다. 4계층의 목적은 목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고  
데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것 입니다.

패킷을 분활하고 조합하기 위해 TCP 프로토콜에서는 시퀀스 번화와 ACK 번호를 사용합니다.

![](https://camo.githubusercontent.com/232d8212b26f8982be615bd4af107677e98ee22df77355dcf2928938d2776691/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f38613663373762352d313464352d346364362d386563612d6239666235313438666437352f44394333443046412d433238412d344346442d383336442d3442333441324144303838305f315f3130325f612e6a706567)

TCP/IP 프로토콜 스택에서 4계층의 상위 프로토콜 지시자는 포트 번호입니다. 일반저긍로 TCP/IP 에서는 클라이언트-서버 방식으로 서비스를 제공하고 클라이언트용 프로그램과  
서버용 프로그램을 구분해 개발합니다. 3계층의 프로토콜 번호나 2계층의 이더 타입과 같은 상위 프로토콜 지시자는 출발지와 도착지를 구분해 사용하지 않고 한 개만 사용하지만  
4계층 프로토콜 지시자인 포트 번호는 출발지와 목적지를 구분해 처리해야 합니다.

평소 우리가 표현하는 포트 번호의 기준의 서버의 포트입니다. 이 포트 번호 중 HTTP TCP 80, HTTPS TCP 443, SMTP TCP 25와 같이 잘 알려진 포ㅌ를 웰 노운 포트라고 합니다.  
이 포트들은 이미 인터넷 주소 할당기구인 LANA에 등록되고 1023번 이하의 포트 번호를 사용합니다.

### TCP

TCP는 4계층의 특징을 대부분 포함하고 있습니다. TCP 프로토콜은 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된  
패킷이 잘 전송되었는지 확인하는 기능이있습니다. 패킷에 번호를 부여하고 잘 전송되었는지에 대해 응답합니다. 또한 한꺼번에 얼마나 보내야 수신자가 잘 받아 처리할 수 있는지 전송 크기까지 고려해 통신합니다.

TCP의 여러 역할 덕분에 네트워크 상태를 심각학게 고려하지 않고 특별한 개발 없이도 쉽고 안전하게 네트워크를 사용할 수 있습니다.

#### 패킷 순서, 응답 번호

TCP에서는 분할된 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여합니다. **패킷에 순서를 부여하는 것을 시퀀스 번호**, **응답 번호를 부여하는 것을 ACK 번호라고 부릅니다.**  
![](https://camo.githubusercontent.com/002c2dff046659a6587d39e1c31f38c7768f523523111326d9582dd0c8c03eaa/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f31626666306538612d626438382d343262622d613930342d3263376261666332623564342f696d6167652e706e67)

보내는 쪽에서 패킷에 번호를 부여하고 받는 쪽은 이 번호의 순서가 맞는지 확인합니다. 받은 패킷 번호가 맞으면 응답을 주는데 이때 다음 번호의 패킷을 요청합니다. 이 숫자를 ACK 번호라고 부릅니다.  
송신 측이 1번 패킷을 보냈는데 수신 측이 이 패킷을 잘 받는다면 1번을 잘 받았으니 다음에는 2번을 달라는 표시로 ACK 번호 2를 줍니다.

![](https://camo.githubusercontent.com/af658a4a5df5349fadbf4c60d7587219c25d7d53de98c276e5cc95af88018dba/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f30616263613737632d373932372d343535312d616565342d3062646138636561636534352f696d6167652e706e67)

1. 출발지에서 시퀀스 번호를 0으로 보냅니다.(SEQ = 0)
2. 수신 측에서는 0번 패킷을 잘 받았다는 표시로 응답 번호(ACK)에 1을 적어 응답합니다. 이때 수신 측에서는 자신이 처음 보내는 패킷이므로 자신의 패킷에 시퀀스 번호 0을 부여합니다.
3. 이 패킷을 받은 송신 측은 시퀀스 번호를 1로(수신 측이 ACK 번호로 1번 패킷을 달라고 요청했으므로), ACK 번호는 상대방의 0번 시퀀스를 잘 받았다는 의미로 시퀀스 번호를 1로 부여해 다시 전송합니다.

#### 윈도 사이즈와 슬라이딩 윈도

- 윈도 사이즈 : 한 번에 받을 수 있는 데이터 크기
- 슬라이딩 윈도 : 네트워크 상황에 따라 윈도 사이즈를 조절하는 것
  TCP는 상대방이 얼마나 잘 받았는지 확인하기 위해 ACK 번호를 확인하고 다음 패킷을 전송한다. 패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신 시간을 늘리지만,  
  송/수신자간 거리가 멀수록 왕복 지연시간(RTT)이 늘어나므로 응답을 기다리는 시간이 더 길어진다.

그래서 데이터를 보낼 때 패킷을 하나만 보내는 것이 아니라 많은 패킷을 한꺼번에 보내고 응답을 하나만 받는다. 최대한 많은 패킷을 한꺼번에 보내는 것이 효율적이지만, 네트워크 상태가 안좋으면  
패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 한다. 한 번에 데이터를 받을 수 있는 데이터 크기를 윈도 사이즈라 하고 네트워크 상황에 따라 이를 조절하는 것을 슬라이딩 윈도라 한다.

#### 3-way Handshake

TCP에서는 유실없는 안전한 통신을 위해 통신 시작 전 사전 열결작업을 진행합니다. 목적지가 데이터를 받을 준비가 안 된 상황에서 데이터를 일반적으로 전송하면 목적지에서는 데이터를 정상적으로  
처리할 수 없어 데이터가 버려지게 됩니다.

TCP 프로토콜은 이런 상황을 만들지 않기 위해 3번의 패킷을 주고받으면서 통신을 서로 준비하므로 3-way Handshake라고 부릅니다.  
![](https://camo.githubusercontent.com/0964cb7f6281ced5cf01fcddff76ac80e9a1a6fb756b2276a56cbe00f5bba5d4/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f30663635396235622d373565332d346639372d626630332d3230313130316264643138662f696d6167652e706e67)

3-way Handshake 과정이 생기다보니 기존 통신과 새로운 통신을 구분해야 합니다. 어떤 패킷이 새로운 연결 시도이고 기존 통신에 대한 응답인지 구분하기 위해 헤더 플래그(Flag)라는 값을 넣어 통신합니다.

![](https://camo.githubusercontent.com/2c2d0a8932e1dde1e613fce405e8efc73a6461e9c0f7c368cf8799e413ca3903/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f65376261666265312d333231372d343033342d616266312d6366313164626233663861322f696d6167652e706e67)

TCP 플래그는 총 6가지가 있고 통신의 성질을 나타냅니다. 초기 연결, 응답, 정상 종료, 비정상 종료 등의 용도로 사용됩니다.

- SYN : 연결 시작 용도로 사용합니다. 연결이 시작될 때 SYN 플래그에 1로 표시해 보냅니다.
- ACK : ACK 번호가 유효할 경우, 1로 표시해 보냅니다. 초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답이므로 ACK 플래그가 1로 표기됩니다.
- FIN : 연결 종료 시 1로 표시됩니다. 데이터 전송을 마친 후 정상적으로 양방향 종료 시 사용됩니다.
- RST : 연결 종료 시 1로 표시됩니다. 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용됩니다.
- URG : 긴급 데이터인 경우 1로 표시해 보냅니다.
- PSH : 서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때 사용됩니다.

![](https://camo.githubusercontent.com/911260aaa96da04c293ebf460df88bf4dd62dd4c3e880452ab318c9e52dc5d68/68747470733a2f2f696d616765732e76656c6f672e696f2f696d616765732f736f6e6773343830352f706f73742f63356666393736362d396434302d343066662d383766322d6332336133353832623539352f696d6167652e706e67)

1. 통신 최초 시도시 송신자는 플래그에 있는 SYN 필드를 1로 표기하고 시퀀스 번호를 적어 보낸다.
2. SYN 패킷을 받은 수신자는 SYN, ACK 비트를 플래그에 1로 표기해 응답한다. 수신자가 보내는 첫 패킷이므로 SYN은 1이고 기존 송신자의 응답이기도 하므로 ACK 비트도 함께 1로 표기한다.  
   이 때 ACK 번호는 송신자가 보낸 시퀀스 번호에 1을 추가한 값을 넣어 응답한다. (시퀀스 번호로 10을 받았으니 ACK 번호는 11을 보내면 됨)
3. 수신자의 응답(SYN, ACK)을 받은 송신자는 연결을 확립하기 위해 다시 응답을 보낸다. 이때는 기존 메시지의 응답이기에 ACK 필드만 1로 표기된다. 수신자가 시퀀스 번호를 20으로 보냈기 때문에 송신자의 ACK 번호는 20+1인 21이 된다.

### UDP

TCP와 달리 UDP는 4계층 프로토콜이 가져야 할 특징이 거의 없습니다.

TCP 헤더에 있던 내용들(시퀀스 번호, ACK 번호, 플래그, 윈도 사이즈 등)이 모두 존재하지 않는다.
데이터 통신은 데이터 전송의 신뢰성이 핵심이다. 애플리케이션에서 걱정하지 않고 데이터를 만들고 사용하게 하는 것이 데이터 통신의 목적이지만, UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용된다.

- 음성 데이터나 실시간 스트리밍  
  실시간성이 보장되야하는 시간에 민감한 프로토콜이나 애플리케이션을 사용하는 경우 UDP 프로토콜이 사용됨
- 단방향으로 다수의 단말과 통신하며 응답을 받기 어려운 환경  
  사내 방송, 증권 시세 데이터 전송 등

즉, 신뢰성보다는 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 시스템에서 UDP를 사용한다. UDP는 중간에 데이터가 일부 유실되더라도 그냥 유실된 상태로 데이터를 처리해버린다.

또한 다음과 같은 특징이 있다.

- UDP는 TCP와 다르게 3방향 핸드셰이크처럼 사전에 연결을 확립하는 과정이 없다. 대신 UDP의 첫 데이터는 리소스 확보를 위해 인터럽트(interrupt)를 거는 용도로 사용되고 유실된다.
- UDP 프로토콜을 사용하는 앱 대부분은 이런 상황을 인지하고 동작한다.
- 연결 확립은 TCP 프로토콜을 이용하고 앱끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분이다.

📌 TCP와 UDP 특징 비교

| TCP                            | UDP                                  |
| ------------------------------ | ------------------------------------ |
| 연결 지향(Connection Oriented) | 비연결형(Connectionless)             |
| 오류 제어 수행함               | 오류 제어 수행 안 함                 |
| 흐름 제어 수행함               | 흐름 제어 수행 안 함                 |
| 유니캐스트                     | 유니캐스트, 멀티캐스트, 브로드캐스트 |
| 전이중(Full Duplex)            | 반이중(Half Duplex)                  |
| 데이터 전송                    | 실시간 트래픽 전송                   |

## 5. ARP

OSI 7계층 중 2, 3계층이 주소를 가지고 있고 통신할 때 목적지를 찾아갈 수 있도록 하지만, 사실 두 계층의 주소간에는 아무 관계가 없다.

2계층 MAC 주소는 하드웨어 생산업체가 임의적으로 할당한 주소이고 NIC에 종속된 주소이다.  
3계층 IP 주소는 우리가 직접 할당하거나 DHCP를 이용해 자동으로 할당받는다.

실제로 통신은 IP 주소 기반으로 일어나고 MAC 주소는 상대방의 주소를 자동으로 알아내 통신하게 된다.  
이때, **상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜이 ARP(Address Resolution Protocol)** 이다.

![](https://images.velog.io/images/songs4805/post/804d8016-3f21-4979-9c37-8a6830175f31/image.png)

TCP-이더넷 프로토콜과 같이 3계층 논리적 주소와 2계층 물리적 주소 사이에 관계가 없는 프로토콜에서 ARP 프로토콜과 같은 메커니즘을 사용해 물리적 주소와 논리적 주소를 연결한다.

호스트에서 아무 통신이 없다가 처음 통신을 시도하면 패킷을 바로 캡슐화 할 수 없다. 통신을 시도할 때 출발지와 목적지 IP는 미리 알고 있어 문제가 없지만, 상대방의 MAC 주소를 알 수 없어 2계층 캡슐화를 수행할 수 없다. 상대방의 MAC 주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC 주소를 질의해야 한다.

ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜로 자신의 MAC 주소를 응답하는데, 이 작업이 완료되면 이제 부족했던 정보인 목적지의 MAC 주소도 알아냈기에 패킷은 정상적으로 인캡슐레이션되어 상대방에게 전달 될 수 있다.

### 목적지 MAC 주소를 매번 ARP 브로드캐스트를 통해 알아내야 하는 것은 아니다

ARP 브로드캐스트를 매번 수행하면 네트워크 통신의 효율성이 크게 저하되므로 메모리에 이 정보를 저장해두고 재사용한다.

IP 주소와 MAC 주소를 1:1로 대응하여 테이블로 저장해두는데 이를 **ARP Table**이라 한다.

- 성능을 위해서는 ARP 테이블이 한 번 생성되면 오래 유지될수록 좋다.
- 논리 주소는 언제든지 바뀔 수 있기 때문에 일정 시간 이상 통신이 없으면 이 테이블은 삭제된다.
- 네트워크 장비에서 ARP 작업은 CPU에서 직접 수행하기 때문에 짧은 시간에 많은 ARP요청이 들어오면 네트워크 장비에는 큰 부하가 걸린다.
- 이 외에도 DNS 캐시나 라우팅 캐시와 같이 다양한 계층에서 네트워크의 성능을 높이기 위한 캐시 테이블을 가지고 있다.

### ARP 동작

ARP 프로토콜 필드 중 다음 4가지 필드가 중요하다.

- 송신자 하드웨어 MAC 주소
- 송신자 IP 프로토콜 주소
- 대상자 MAC 주소
- 대상자 IP 프로토콜 주소

#### 1. 서버 A → 서버 B로 최초 통신 시도

![](https://images.velog.io/images/songs4805/post/1aa2af92-d149-463f-aed5-d4f7ec3c07ed/image.png)

- 목적지 MAC 주소를 모르기에 패킷을 완성할 수 없음
- 서버 A는 서버 B의 MAC 주소를 알아내기 위해 ARP 요청을 브로드캐스트 해야 함.

#### 2. 서버 A → 서버 B로 ARP 브로드캐스트

![](https://images.velog.io/images/songs4805/post/0f9c9a37-a5d6-493c-b256-a4d59f96c55d/image.png)

- 2계층 MAC 주소는 출발지를 자신의 MAC으로, 도착지는 브로드캐스트(FF-FF-FF-FF-FF-FF)
- ARP 프로토콜 필드의 전송자 MAC과 IP 주소에는 자신의 주소로 채운다.
- 대상자 IP 주소는 1.1.1.2로 대상자 MAC 주소는 00-00-00-00-00-00으로 채워보낸다.

#### 3. 브로드캐스트를 받은 서버에서는 IP 비교 후 자신의 MAC 주소 반환

![](https://images.velog.io/images/songs4805/post/2e52eb90-dfff-4163-ad5a-eff66f6f2356/image.png)

- 이전 단계에서 브로드캐스트로 전송했기에 ARP 패킷은 같은 네트워크 내의 모든 단말에 보내졌다. 모든 단말은 각자 ARP 프로토콜을 확인한 뒤 대상자 IP가 자신의 IP와 비교해서 일치하지 않으면 폐기한다. 만약 일치한다면 받은 ARP 프로토콜 필드를 통해 목적지 정보(IP, MAC)도 알 수 있기 때문에 이를 이용해 ARP 프로토콜을 보내는데 모든 값이 채워져 있으므로 유니캐스트로 전송된다.

#### 4. ARP 캐시 테이블 갱신 및 서버 A → 서버 B 패킷 송신

![](https://images.velog.io/images/songs4805/post/bcc3a762-a789-4a29-9f13-78a152399f06/image.png)

- 서버 A는 서버 B로부터 ARP 응답을 받아 자신의 ARP 캐시 테이블을 갱신한다.
- 이 ARP 캐시 테이블은 정해진 시간동안 서버 B와 통신이 없을때까지 유지되며 시간 내에 통신이 다시 이뤄지면 시간은 다시 초기화된다.
- ARP 캐시 테이블 갱신 후에는 상대방의 MAC 주소를 알고 있으므로 도착지 MAC 주소 필드도 완성해서 인캡슐레이션해서 정상적으로 패킷을 보낼 수 있다.

## 6. 서브넷과 게이트웨이

**원격지 네트워크와의 통신에서 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질때문에 사용되는 장비를 게이트웨이(Gateway)라 부른다.**

![](https://images.velog.io/images/songs4805/post/2637f3ef-ab25-4595-b528-ae5f63d119c1/image.png)

- 기본 게이트웨이는 3계층 장비가 수행하며 여러 네트워크와 연결되어 적절한 경로를 지정해주는 역할을 한다.
- 출발지와 목적지 네트워크가 동일한 LAN 내에서 통신하는 것인지 다른 네트워크 간의 통신인지에 따라 통신 방식이 달라지기에 먼저 목적지의 범위를 **서브넷 마스크**를 이용해 확인한다.
- 원격지 통신은 ARP가 라우터를 넘어가지 못하는 브로드캐스트이기에 게이트웨이라는 장비를 사용해야 한다.

### 2계층 통신 vs 3계층 통신

![](https://images.velog.io/images/songs4805/post/9b8bd264-95f7-4a63-8603-bdcb4f4e7454/image.png)

- **3계층 통신**: 원격지 네트워크 통신  
  원격지 네트워크와 통신해야 할 경우 라우터와 같은 3계층 장비의 도움이 필요하기 때문에 해당 패킷을 전송하는 네트워크 장비에서 3계층 정보까지 확인해야 하며 이를 L3 통신이라 한다. 도착지 MAC 주소와 IP 주소가 다르다. 도착지 IP 주소는 실제 도착지이고 도착지 MAC 주소는 디폴트 게이트웨이의 MAC 주소가 사용된다.
- **2계층 통신**: 로컬 네트워크 통신  
  로컬 네트워크에서 직접 통신할 경우 라우터와 같은 3계층 장비 없이도 통신이 가능하다. 그래서 2계층까지만 정보를 확인 후 ARP 요청을 보낼 때 직접 브로드캐스트를 이용하기에 L2 통신이라 한다.
